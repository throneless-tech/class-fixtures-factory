{"version":3,"file":"class-fixtures-factory.cjs.production.min.js","sources":["../src/common/utils.ts","../src/metadata/BaseMetadataStore.ts","../src/metadata/ClassValidatorAdapter.ts","../src/metadata/DefaultMetadataStore.ts","../src/FactoryLogger.ts","../src/FixtureFactory.ts","../src/decorators/Fixture.ts"],"sourcesContent":["/**\n * Get possible values from an enum\n * @param enumObj\n */\nexport const getEnumValues = (enumObj: any) => {\n  const keysList = Object.getOwnPropertyNames(enumObj).filter(key => {\n    // eslint-disable-next-line no-prototype-builtins\n    return enumObj.propertyIsEnumerable(key) && key !== String(parseFloat(key));\n  });\n  const length = keysList.length;\n  const valuesList = new Array<any>(length);\n  for (let index = 0; index < length; ++index) {\n    const key = keysList[index];\n    const value = enumObj[key];\n    valuesList[index] = value;\n  }\n  return valuesList;\n};\n","import { Class } from '../common/typings';\n\nexport interface ClassMetadata {\n  name: string;\n  properties: PropertyMetadata[];\n}\n\nexport interface PropertyMetadata {\n  name: string;\n  type: string;\n  scalar?: boolean;\n  enum?: boolean;\n  items?: any[];\n  array?: boolean;\n  ignore?: boolean;\n  min?: number;\n  max?: number;\n  optional?: boolean;\n  input?: (...args: any[]) => any;\n}\n\nexport abstract class BaseMetadataStore {\n  protected store: Record<string, ClassMetadata> = {};\n  get(classType: Class | string) {\n    const name = typeof classType === 'string' ? classType : classType.name;\n    const value = this.store[name];\n    if (!value) throw new Error(`Cannot find metadata for class \"${name}\"`);\n    return value;\n  }\n  abstract make(classType: Class): ClassMetadata;\n}\n","import { ValidationMetadata } from 'class-validator/metadata/ValidationMetadata';\nimport { getFromContainer, MetadataStorage } from 'class-validator';\nimport faker from 'faker';\nimport { PropertyMetadata } from '.';\nimport { Class } from '..';\n\ninterface WorkingData {\n  type?: 'number' | 'decimal' | 'date' | 'alpha' | 'alphanumeric' | 'array';\n  min?: number | Date;\n  max?: number | Date;\n  case?: 'lower' | 'upper';\n  options?: any;\n}\n\nexport class ClassValidatorAdapter {\n  private metadata: Record<string, ValidationMetadata[]> = {};\n\n  extractMedatada(classType: Class) {\n    const metadata = getFromContainer(\n      MetadataStorage\n    ).getTargetValidationMetadatas(classType, '');\n    return (this.metadata[classType.name] = metadata);\n  }\n\n  makePropertyMetadata(\n    cvMeta: ValidationMetadata,\n    existingProp: PropertyMetadata | undefined\n  ): PropertyMetadata | Partial<PropertyMetadata> | null {\n    const prop: Partial<PropertyMetadata> = {\n      name: cvMeta.propertyName,\n      ...(existingProp || {}),\n    };\n    const data: WorkingData = {\n      type: null as any,\n      max: null as any,\n      min: null as any,\n    };\n\n    switch (cvMeta.type) {\n      case 'isBoolean': {\n        return {\n          ...prop,\n          type: prop.type || 'boolean',\n          input: () => faker.random.boolean(),\n        } as PropertyMetadata;\n      }\n      case 'isDate': {\n        data.type = 'date';\n        break;\n      }\n      case 'isString': {\n        data.type = 'alpha';\n        break;\n      }\n      case 'isNumber':\n      case 'isInt':\n      case 'isNumberString': {\n        data.type = 'number';\n        break;\n      }\n      case 'isIn': {\n        const items = cvMeta.constraints[0];\n        return {\n          ...prop,\n          type: prop.type || 'any',\n          input: () => faker.random.arrayElement(items),\n        } as PropertyMetadata;\n      }\n      case 'equals':\n        return {\n          ...prop,\n          type: prop.type || 'any',\n          input: () => cvMeta.constraints[0],\n        };\n      case 'isEmpty':\n        return {\n          ...prop,\n          type: prop.type || 'any',\n          input: () => null,\n        };\n      case 'isPositive':\n        data.type = 'number';\n        data.min = 1;\n        break;\n      case 'isNegative':\n        data.type = 'number';\n        data.max = -1;\n        break;\n      case 'min': {\n        const value = cvMeta.constraints[0];\n        data.type = 'number';\n        data.min = value;\n        break;\n      }\n      case 'max': {\n        const value = cvMeta.constraints[0];\n        data.type = 'number';\n        data.max = value;\n        break;\n      }\n      case 'minDate': {\n        const value = cvMeta.constraints[0];\n        data.type = 'date';\n        data.min = value;\n        break;\n      }\n      case 'maxDate': {\n        const value = cvMeta.constraints[0];\n        data.type = 'date';\n        data.max = value;\n        break;\n      }\n      case 'contains': {\n        const value = cvMeta.constraints[0];\n        return {\n          ...prop,\n          type: prop.type || 'any',\n          input: () => `${faker.random.word()}${value}${faker.random.word()}`,\n        };\n      }\n      case 'isAlpha':\n        data.type = 'alpha';\n        break;\n      case 'isAlphanumeric':\n        data.type = 'alphanumeric';\n        break;\n      case 'isDecimal':\n        data.options = cvMeta.constraints[0];\n        data.type = 'decimal';\n        break;\n      case 'isEmail':\n        return {\n          ...prop,\n          type: 'string',\n          input: () => faker.internet.email(),\n        };\n      case 'isFqdn':\n        return {\n          ...prop,\n          type: 'string',\n          input: () => faker.internet.domainName(),\n        };\n      case 'isHexColor':\n        return {\n          ...prop,\n          type: 'string',\n          input: () => faker.internet.color(),\n        };\n      case 'isLowercase':\n        data.type = 'alpha';\n        data.case = 'lower';\n        break;\n      case 'isUppercase':\n        data.type = 'alpha';\n        data.case = 'upper';\n        break;\n      case 'length': {\n        const [min, max] = cvMeta.constraints;\n        data.min = min;\n        data.max = max || 6;\n        data.type = 'alpha';\n        break;\n      }\n      case 'minLength': {\n        const value = cvMeta.constraints[0];\n        data.min = value;\n        data.type = 'alpha';\n        break;\n      }\n      case 'maxLength': {\n        const value = cvMeta.constraints[0];\n        data.max = value;\n        data.type = 'alpha';\n        break;\n      }\n      case 'arrayContains': {\n        const value = cvMeta.constraints[0];\n        return {\n          ...prop,\n          type: 'string',\n          input: () => value,\n        };\n      }\n      case 'arrayMinSize': {\n        const value = cvMeta.constraints[0];\n        data.type = 'array';\n        data.min = value;\n        break;\n      }\n      case 'arrayMaxSize': {\n        const value = cvMeta.constraints[0];\n        data.type = 'array';\n        data.max = value;\n        break;\n      }\n    }\n\n    if (typeof data.max === 'number' && !data.min) {\n      data.min = data.max - 1;\n    } else if (typeof data.min === 'number' && !data.max) {\n      data.max = data.min + 1;\n    }\n    if (\n      typeof data.max === 'number' &&\n      typeof data.min === 'number' &&\n      data.min > data.max\n    ) {\n      data.max = data.min + 1;\n    }\n\n    switch (data.type) {\n      case 'number': {\n        const min = data.min as number;\n        const max = data.max as number;\n        const sign = max < 0 ? -1 : 1;\n        let value =\n          sign *\n          faker.random.number({\n            min: Math.abs(min || sign),\n            max: Math.abs(max || 10000),\n          });\n        return {\n          ...prop,\n          type: 'number',\n          input: () => value,\n        };\n      }\n      case 'decimal': {\n        const min = data.min as number;\n        const max = data.max as number;\n        const digits = Number(data.options.decimal_digits || '1');\n        const sign = max < 0 ? -1 : 1;\n        let value =\n          sign *\n          parseFloat(\n            faker.finance.amount(\n              Math.abs(min || sign),\n              Math.abs(max || 10000),\n              digits\n            )\n          );\n        return {\n          ...prop,\n          type: 'number',\n          input: () => value,\n        };\n      }\n      case 'date': {\n        const min = data.min as Date;\n        const max = data.max as Date;\n        let value: Date;\n        if (min) {\n          value = faker.date.between(min, max || faker.date.future(1, min));\n        } else if (max) {\n          value = faker.date.between(min || faker.date.past(1, max), max);\n        } else {\n          value = faker.date.recent();\n        }\n        return {\n          ...prop,\n          type: 'Date',\n          input: () => value,\n        };\n      }\n      case 'alpha': {\n        const min = data.min as number;\n        const max = data.max as number;\n        const ln = faker.random.number({ min: min || 5, max: max || 10 });\n        const value = faker.lorem\n          .sentence(100)\n          .substr(0, ln)\n          [data.case === 'lower' ? 'toLowerCase' : 'toUpperCase']();\n        return {\n          ...prop,\n          type: 'string',\n          input: () => value,\n        };\n      }\n      case 'alphanumeric': {\n        const min = data.min as number;\n        const max = data.max as number;\n        const ln = faker.random.number({ min: min || 5, max: max || 10 });\n        return {\n          ...prop,\n          type: 'string',\n          input: () =>\n            faker.random\n              .alphaNumeric(ln)\n              [data.case === 'lower' ? 'toLowerCase' : 'toUpperCase'](),\n        };\n      }\n      case 'array': {\n        if (!prop.type) {\n          throw new Error(\n            `The type of \"${cvMeta.propertyName}\" seems to be an array. Use @Fixture({ type: () => Foo })`\n          );\n        }\n        return {\n          ...prop,\n          max: (data.max as number) || prop.max,\n          min: (data.min as number) || prop.min,\n        };\n      }\n    }\n\n    if (!prop.type) {\n      return null;\n    }\n\n    return prop;\n  }\n}\n","import {\n  BaseMetadataStore,\n  ClassMetadata,\n  PropertyMetadata,\n} from './BaseMetadataStore';\nimport { Class } from '../common/typings';\nimport reflect, { PropertyReflection } from 'tinspector';\nimport { FixtureOptions } from '../decorators/Fixture';\nimport { getEnumValues } from '../common/utils';\nimport { ClassValidatorAdapter } from './ClassValidatorAdapter';\n\nexport class DefaultMetadataStore extends BaseMetadataStore {\n  private cvAdapter = new ClassValidatorAdapter();\n\n  constructor(private readonly acceptPartialResult = false) {\n    super();\n  }\n  /**\n   * Make type metadata for a class\n   * @param classType\n   */\n  make(classType: Class): ClassMetadata {\n    const rMetadata = reflect(classType);\n    const cvMetadata = this.cvAdapter.extractMedatada(classType);\n\n    const unknownTypes = new Set<string>();\n    let properties = rMetadata.properties\n      .map(prop => this.makePropertyMetadata(prop)!)\n      .filter(Boolean);\n    for (const cvMeta of cvMetadata) {\n      const existingProp = properties.find(\n        prop => prop.name === cvMeta.propertyName\n      );\n      const deducedProp = this.cvAdapter.makePropertyMetadata(\n        cvMeta,\n        existingProp\n      ) as PropertyMetadata | null;\n      if (deducedProp) {\n        if (existingProp) {\n          properties = properties.map(prop =>\n            prop.name === cvMeta.propertyName ? deducedProp : existingProp\n          );\n        } else {\n          properties.push(deducedProp);\n        }\n        unknownTypes.delete(cvMeta.propertyName);\n      } else {\n        const typeResolved = !!properties.find(\n          v => v.name === cvMeta.propertyName && !!v.type\n        );\n        if (!typeResolved) {\n          unknownTypes.add(cvMeta.propertyName);\n        }\n      }\n    }\n\n    if (unknownTypes.size > 0) {\n      throw new Error(\n        `Couldn't extract the type of ${[...unknownTypes]\n          .map(v => `\"${v}\"`)\n          .join(', ')}. Use @Fixture({ type: () => Foo })`\n      );\n    }\n\n    const classMetadata: ClassMetadata = {\n      name: rMetadata.name,\n      properties: properties.filter(Boolean),\n    };\n    return (this.store[classType.name] = classMetadata);\n  }\n\n  private makePropertyMetadata(\n    prop: PropertyReflection\n  ): PropertyMetadata | null {\n    const decorator = this.getFixtureDecorator(prop);\n    const meta: Partial<PropertyMetadata> = {\n      name: prop.name,\n      scalar: prop.typeClassification === 'Primitive',\n    };\n    if (decorator) {\n      if (typeof decorator === 'function') {\n        meta.input = decorator.bind(decorator, require('faker'));\n      } else if (typeof decorator === 'string') {\n        meta.input = () => decorator;\n      } else if (typeof decorator === 'object') {\n        if (decorator.ignore) return null;\n        meta.input = decorator.get;\n        meta.min = decorator.min || 1;\n        meta.max = decorator.max || 3;\n        meta.optional = decorator.optional || false;\n        let inputType: any = decorator.type?.();\n        if (inputType) {\n          if (Array.isArray(inputType)) {\n            inputType = inputType[0];\n            meta.array = true;\n          }\n          if (!inputType.prototype) {\n            throw new Error(\n              `Only pass class names to \"type\" in @Fixture({ type: () => Foo}) for \"${meta.name}\"`\n            );\n          }\n          const { name } = inputType;\n          if (!['string', 'number', 'boolean'].includes(name.toLowerCase())) {\n            meta.type = name;\n          } else {\n            meta.type = name.toLowerCase();\n          }\n        }\n        if (decorator.enum) {\n          meta.enum = true;\n          meta.items = getEnumValues(decorator.enum);\n        }\n      }\n    }\n    if (!meta.type) {\n      if (!prop.type) {\n        if (this.acceptPartialResult) {\n          return meta as PropertyMetadata;\n        }\n      } else if (Array.isArray(prop.type)) {\n        throw new Error(\n          `The type of \"${meta.name}\" seems to be an array. Use @Fixture({ type: () => Foo })`\n        );\n      } else if (prop.type instanceof Function) {\n        const { name } = prop.type as Function;\n        if (!['string', 'number', 'boolean'].includes(name.toLowerCase())) {\n          meta.type = name;\n        } else {\n          meta.type = name.toLowerCase();\n        }\n      }\n    }\n    if (!meta.type) {\n      throw new Error(\n        `Couldn't extract the type of \"${meta.name}\". Use @Fixture({ type: () => Foo })`\n      );\n    }\n    return meta as PropertyMetadata;\n  }\n\n  private getFixtureDecorator(prop: PropertyReflection): FixtureOptions {\n    return prop.decorators.find(v => v.type === 'Fixture')?.value || null;\n  }\n}\n","import { ClassMetadata, PropertyMetadata } from './metadata';\nimport chalk from 'chalk';\nimport treeify from 'treeify';\n\nexport class FactoryLogger {\n  private rootTree: any = {};\n  private tree: any = {};\n  private duplicates: Record<string, number> = {};\n\n  start(meta: ClassMetadata, number = 0) {\n    const entry = `Generated an instance of ${chalk.gray('\"')}${chalk.cyan(\n      meta.name\n    )}${chalk.gray('\"')}${number ? `${chalk.gray(` (${number})`)}` : ''}`;\n    this.rootTree[entry] = {};\n    this.tree = this.rootTree[entry];\n  }\n\n  onIgnoreProp(prop: PropertyMetadata) {\n    const name = chalk.cyan(prop.name);\n    this.tree[name] = chalk.gray(`(ignored)`);\n  }\n\n  onCustomProp(prop: PropertyMetadata) {\n    const name = chalk.cyan(prop.name);\n    this.tree[name] = chalk.gray(`(custom value)`);\n  }\n\n  onClassPropDone(prop: PropertyMetadata, targetLogger: FactoryLogger) {\n    const name = chalk.cyan(prop.name);\n    if (this.tree[name]) {\n      const number = (this.duplicates[prop.name] =\n        (this.duplicates[prop.name] || 0) + 1);\n      const entry = (val: number) =>\n        `Generated an instance of ${chalk.gray('\"')}${chalk.cyan(\n          prop.type\n        )}${chalk.gray('\"')}${chalk.gray(` (${val})`)}`;\n      const firstKey = Object.keys(this.tree[name])[0];\n      if (number === 1) {\n        this.tree[name][entry(number - 1)] = this.tree[name][firstKey];\n        delete this.tree[name][firstKey];\n      }\n      this.tree[name][entry(number)] = targetLogger.rootTree;\n    } else {\n      this.tree[name] = targetLogger.rootTree;\n    }\n  }\n\n  onNormalProp(prop: PropertyMetadata, value: any) {\n    const name = chalk.cyan(prop.name);\n    this.tree[name] = value;\n  }\n\n  onClassValidator(prop: PropertyMetadata, value: any) {\n    const name = chalk.cyan(prop.name);\n    this.tree[name] = `${chalk.gray('class-validator]')} ${value}`;\n  }\n\n  onDone(duration: number) {\n    this.tree[`${chalk.green('Done')} ${chalk.gray(`(${duration}ms)`)}`] = null;\n  }\n\n  onError(duration: number) {\n    this.tree[`${chalk.red('Error')} ${chalk.gray(`(${duration}ms)`)}`] = null;\n  }\n\n  log() {\n    return treeify.asTree(this.rootTree, true, false);\n  }\n}\n","import {\n  BaseMetadataStore,\n  DefaultMetadataStore,\n  ClassMetadata,\n  PropertyMetadata,\n} from './metadata';\nimport { Class } from './common/typings';\nimport faker from 'faker';\nimport chalk from 'chalk';\nimport { FactoryLogger } from './FactoryLogger';\n//import { ClassValidatorAdapter } from './ClassValidatorAdapter';\n\nexport interface FactoryOptions {\n  logging?: boolean;\n  maxDepth?: number;\n}\n\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<DeepPartial<U>>\n    : T[P] extends ReadonlyArray<infer U>\n    ? ReadonlyArray<DeepPartial<U>>\n    : DeepPartial<T[P]>;\n};\n\nexport interface FactoryResult<T> {\n  one: () => T;\n  many: (x: number) => T[];\n  with: (input: DeepPartial<T>) => FactoryResult<T>;\n  ignore: (...props: (keyof T)[]) => FactoryResult<T>;\n}\n\nexport type Assigner = (\n  prop: PropertyMetadata,\n  object: any,\n  value: any\n) => void;\n\nexport class FixtureFactory {\n  private store: BaseMetadataStore;\n  private classTypes: Record<string, Class> = {};\n  private DEFAULT_OPTIONS: FactoryOptions = {\n    logging: false,\n    maxDepth: 4,\n  };\n  private options!: FactoryOptions;\n  private loggers: FactoryLogger[] = [];\n  private assigner: Assigner = this.defaultAssigner.bind(this);\n  //private cvAdapter = new ClassValidatorAdapter();\n\n  constructor(options?: FactoryOptions) {\n    this.store = new DefaultMetadataStore();\n    this.options = {\n      ...this.DEFAULT_OPTIONS,\n      ...(options || {}),\n    };\n  }\n\n  private defaultAssigner(prop: PropertyMetadata, object: any, value: any) {\n    object[prop.name] = value;\n  }\n\n  /**\n   * Set a function to take charge of assigning values to\n   * generated objects\n   * @param fn\n   */\n  setAssigner(fn: Assigner) {\n    this.assigner = fn;\n  }\n\n  /**\n   * You can set a custom metadata store\n   * for extension purposes.\n   * The store should extends `BaseMetadataStore`\n   * @param store\n   */\n  setMetadataStore(store: BaseMetadataStore) {\n    this.store = store;\n  }\n\n  /**\n   * Returns the instance of the metadata store\n   */\n  getStore() {\n    return this.store;\n  }\n\n  /**\n   * Attemps to log a message.\n   * Won't work if logging is disabled.\n   * @param msg\n   */\n  log(msg: string, force = false) {\n    if (force || this.options.logging) {\n      console.log(chalk.gray('[FixtureFactory] '), msg);\n    }\n  }\n\n  newLogger(meta: ClassMetadata) {\n    this.loggers.unshift(new FactoryLogger());\n    const logger = this.logger();\n    logger.start(meta);\n    return logger;\n  }\n\n  logger() {\n    return this.loggers[0];\n  }\n\n  printLogger(dispose = false) {\n    const logger = this.logger();\n    if (!logger) return;\n    this.log('\\n' + logger.log());\n    if (dispose) {\n      this.disposeLogger();\n    }\n  }\n\n  disposeLogger() {\n    this.loggers.shift();\n  }\n\n  /**\n   * Register classes to be used by the factory\n   * @param classTypes\n   */\n  register(classTypes: Class[]) {\n    for (const classType of classTypes) {\n      this.store.make(classType);\n      this.classTypes[classType.name] = classType;\n    }\n  }\n\n  /**\n   * Generate fixtures\n   * @param classType\n   */\n  make<T extends Class>(classType: T): FactoryResult<InstanceType<T>> {\n    this.store.make(classType);\n    const meta = this.store.get(classType);\n    let propsToIgnore: string[] = [];\n    let userInput: DeepPartial<T> = {};\n\n    const result: FactoryResult<InstanceType<T>> = {\n      one: () => {\n        let error = false;\n        let object: any = {};\n        const startDate = new Date();\n        this.newLogger(meta);\n\n        try {\n          object = this._make(meta, classType, propsToIgnore);\n          for (const [key, value] of Object.entries(userInput)) {\n            object[key] = value;\n          }\n        } catch (err) {\n          this.log(\n            chalk.red(`An error occured while generating \"${meta.name}\"`),\n            true\n          );\n          console.error(err);\n          error = true;\n        }\n\n        const elapsed = +new Date() - +startDate;\n        this.logger()[error ? 'onError' : 'onDone'](elapsed);\n        this.printLogger(true);\n        return error ? null : object;\n      },\n      many: (x: number) => {\n        return [...Array(x).keys()].map(() => result.one());\n      },\n      with: (input: DeepPartial<T>) => {\n        userInput = input;\n        for (const key of Object.keys(input)) {\n          propsToIgnore.push(key);\n        }\n        return result;\n      },\n      ignore: (...props: any[]) => {\n        propsToIgnore = propsToIgnore.concat(props as string[]);\n        return result;\n      },\n    };\n    return result;\n  }\n\n  protected _make(\n    meta: ClassMetadata,\n    classType: Class,\n    propsToIgnore: string[] = [],\n    depth: number = 0\n  ) {\n    const object = new classType();\n    for (const prop of meta.properties) {\n      if (propsToIgnore.includes(prop.name)) continue;\n      if (this.shouldIgnoreProperty(prop)) continue;\n      this.assigner(prop, object, this.makeProperty(prop, meta, depth + 1));\n    }\n    return object;\n  }\n\n  protected shouldIgnoreProperty(prop: PropertyMetadata) {\n    //if (prop.type === 'method') return true;\n    if (prop.ignore) return true;\n    return false;\n  }\n\n  protected makeProperty(\n    prop: PropertyMetadata,\n    meta: ClassMetadata,\n    depth: number\n  ): any {\n    if (prop.input) {\n      this.logger().onCustomProp(prop);\n      return prop.input();\n    }\n    if (prop.scalar) {\n      const value = this.makeScalarProperty(prop);\n      this.logger().onNormalProp(prop, value);\n      return value;\n    } else if (prop.array) {\n      return this.makeArrayProp(prop, meta, depth);\n    }\n    return this.makeObjectProp(meta, prop, depth);\n  }\n\n  protected makeScalarProperty(prop: PropertyMetadata) {\n    if (prop.enum) {\n      if (prop.items) {\n        return faker.random.arrayElement(prop.items);\n      }\n    }\n    switch (prop.type) {\n      case 'string':\n        return faker.random.word();\n      case 'number':\n        return faker.random.number();\n      case 'boolean':\n        return faker.random.boolean();\n      case 'Date':\n        return faker.date.recent();\n      default:\n        break;\n    }\n    throw new Error(`Can't generate a value for this scalar`);\n  }\n\n  private makeArrayProp(\n    prop: PropertyMetadata,\n    meta: ClassMetadata,\n    depth: number\n  ) {\n    const amount = faker.random.number({\n      max: prop.max,\n      min: prop.min,\n    });\n    if (this.options.maxDepth && depth >= this.options.maxDepth) return [];\n    if (['string', 'number', 'boolean', 'Date'].includes(prop.type)) {\n      return [...Array(amount).keys()].map(() =>\n        this.makeProperty(\n          {\n            ...prop,\n            array: false,\n            scalar: true,\n          },\n          meta,\n          depth\n        )\n      );\n    }\n    return [...Array(amount).keys()].map(() =>\n      this.makeProperty(\n        {\n          ...prop,\n          array: false,\n        },\n        meta,\n        depth\n      )\n    );\n  }\n\n  private makeObjectProp(\n    meta: ClassMetadata,\n    prop: PropertyMetadata,\n    depth: number\n  ) {\n    const refClassMeta = this.store.get(prop.type);\n    const props = this.findRefSideProps(meta, prop);\n\n    const oldLogger = this.logger();\n    const logger = this.newLogger(refClassMeta);\n\n    let value;\n    if (\n      !this.options.maxDepth ||\n      !(\n        this.options.maxDepth &&\n        depth >= this.options.maxDepth &&\n        prop.optional\n      )\n    ) {\n      value = this._make(\n        refClassMeta,\n        this.classTypes[prop.type],\n        props.map(p => p.name),\n        depth\n      );\n    }\n\n    oldLogger.onClassPropDone(prop, logger);\n    this.disposeLogger();\n\n    return value;\n  }\n\n  private findRefSideProps(meta: ClassMetadata, prop: PropertyMetadata) {\n    const props: PropertyMetadata[] = [];\n    const refClassMeta = this.store.get(prop.type);\n    for (const refProp of refClassMeta.properties) {\n      if (refProp.type === meta.name) {\n        props.push(refProp);\n      }\n    }\n    return props;\n  }\n}\n","import { decorateProperty } from 'tinspector';\n\nexport type FixtureOptions =\n  | string\n  | ((faker?: Faker.FakerStatic) => string | undefined)\n  | (() => any)\n  | {\n      type?: () => object;\n      ignore?: boolean;\n      enum?: object;\n      min?: number;\n      max?: number;\n      get?: ((faker?: Faker.FakerStatic) => string | undefined) | (() => any);\n      optional?: boolean;\n    };\n\n/**\n * Decorator for providing metadata about a property\n * or for customizing the generate fixture\n * @param options\n */\nexport function Fixture(options?: FixtureOptions) {\n  return decorateProperty({\n    type: 'Fixture',\n    value: options,\n  });\n}\n"],"names":["getEnumValues","enumObj","keysList","Object","getOwnPropertyNames","filter","key","propertyIsEnumerable","String","parseFloat","length","valuesList","Array","index","this","BaseMetadataStore","classType","name","value","store","Error","ClassValidatorAdapter","metadata","getFromContainer","MetadataStorage","getTargetValidationMetadatas","cvMeta","existingProp","prop","propertyName","data","type","max","min","__assign","input","faker","random","boolean","items_1","constraints","arrayElement","value_1","word","options","internet","email","domainName","color","_a","__read","value_2","value_3","sign","number","Math","abs","digits","Number","decimal_digits","value_4","finance","amount","value_5","date","between","future","past","recent","ln","value_6","lorem","sentence","substr","ln_1","alphaNumeric","acceptPartialResult","_super","_this","__extends","DefaultMetadataStore","rMetadata","reflect","cvMetadata","cvAdapter","extractMedatada","unknownTypes","Set","properties","map","makePropertyMetadata","Boolean","find","deducedProp","this_1","push","v","add","cvMetadata_1","__values","size","__spread","join","classMetadata","decorator","getFixtureDecorator","meta","scalar","typeClassification","bind","require","ignore","get","optional","inputType","isArray","array","prototype","name_1","includes","toLowerCase","items","Function","name_2","decorators","FactoryLogger","entry","chalk","gray","cyan","rootTree","tree","targetLogger","duplicates","val","firstKey","keys","duration","green","red","treeify","asTree","logging","maxDepth","defaultAssigner","DEFAULT_OPTIONS","FixtureFactory","object","fn","assigner","msg","force","console","log","loggers","unshift","logger","start","dispose","disposeLogger","shift","classTypes","classTypes_1","make","propsToIgnore","userInput","result","one","error","startDate","Date","newLogger","_make","_b","entries","_d","err","elapsed","printLogger","many","x","with","_i","props","concat","depth","shouldIgnoreProperty","makeProperty","onCustomProp","makeScalarProperty","onNormalProp","makeArrayProp","makeObjectProp","refClassMeta","findRefSideProps","oldLogger","p","onClassPropDone","refProp","decorateProperty"],"mappings":"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"}